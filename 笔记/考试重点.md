## 考试重点

[toc]



### 第一讲：

#### 软件代码漏洞分类，并简要加以说明

1. 输入验证与表示
   1. 安全问题起因于对输入的信息过度信任，对输入信息未做任何验证引发的安全问题。如：缓冲区溢出、跨站脚本、SQL注入、cache攻击等。
2. API误用
   1. 调用者违反了调用者和被调者之间的约定。如：危险函数、堆检查、未检查的返回值等。
3. 安全特征
   1. 安全特征主要关系到认证、访问控制、机密性、密码、权限管理等方面的内容。如：不安全随机数、最小权限违规、缺少访问控制、口令管理、隐私违规等。
4. 时间与状态
   1. 在多核、多CPU或者分布式系统，经常会发生两个事件同时发生（精确的时间）。线程、进程、时间以及状态的非预期交互可能引起程序缺陷。如：死锁、固定会话、访问资源冲突、不安全临时文件等。
5. 错误处理
   1. 错误处理不足或不处理；产生错误时泄漏了太多信息或不能安全处理这些信息。
6. 代码质量
   1. 软件质量欠佳可能导致不可预知的行为。如：空指针调用、内存泄露、未初始化变量、未释放资源、释放后使用、双重释放等。
7. 封装
   1. 封装的作用是画出清晰的边界。信任与信任模型需要小心处理边界问题。如服务器上，经验证的数据和未经验证的数据之间（可信任边界违规），一个用户数据和另一个用户的数据之间（用户间数据泄露），允许用户看到的数据和不允许用户看到的数据之间（权限控制）、系统数据和调试信息的泄露等。

#### 什么是程序的静态检测和动态检测？两种检测方法各有什么特点？

1. 动态检测：就是通过运行软件，在程序运行过程中注入测试数据，观察程序运行是否正常、输出是否符合程序意图，达到寻找程序漏洞的目的。
   1. 动态检测是一种精确的检测方法。
   2. 动态检测分析结果往往依赖特定的输入、调度和执行路径，容易出现错误定位不准确、漏报等情况。
2. 静态检测：不实际运行程序情况下，通过扫描程序的代码，从程序代码的内部结构和特性上检测漏洞。
   1. 静态检测审核速度快。
   2. 会产生误报和漏报现象。

#### 简要说明哪几类问题可以应用软件静态分析技术及其起到的作用。

- 类型检查
  - 消除全部类型的编程错误，通过编译时捕获错误来防止运行错误。
- 风格检查
  - 纯粹的风格检查程序强制执行的规则一般与空格、命名、注释、程序结构等相关。风格检查所展示的错误往往都是影响代码的可读性和可维护性，不会指出程序运行时会发生的错误。
- 程序理解
  - 帮助用户搞懂代码库中的大量代码。如：提供程序的 概貌视图、查找本方法的所有应用等等。
- 程序验证和属性检查
  - 程序验证工具接受一份规格说明和一份代码，尝试证明该代码忠实实现了这份规格说明。目前程序验证还不能处理任何大型的程序。
    		目前，更为常见的程序验证是根据部分程序行为的部分规格说明对软件进行检查，称为属性检查。
- Bug查找
  - 指出程序以程序员设想之外的方式运行的一些地方。
- 安全审查
  - 以安全为中心的静态分析往往使用了许多技术，现代安全审查工具往往更像是一种属性检查和Bug查找程序的混合体。

#### 请画出软件安全静态检测的基本结构图；说明本地分析和全局分析都是针对什么情况的分析手段，都包含什么技术。

![](C:\Users\15052\Desktop\博客\程序安全检测\静态分析框架图.png)

- 预处理
  - 整个系统的入口，也是其他各部分工作的基础。其主要任务是读取待检测的文件，对其进行词法分析、语法分析等操作，并抽取文件中有价值的信息生成抽象语法树(AST)。
- 控制流分析
  - 该部分主要功能是生成待检测源代码的控制流图CFG（control flow graph）。他通过遍历预处理中生成的抽象语法树，依据程序的执行规则，分析程序的可能执行路径，生成CFG供后续检测工具使用。
- 数据流分析
  - 数据流分析指的是一组用来获取有关数据是如何沿着程序执行路径流动的技术，通常通过对某个函数控制流图的遍历，来记录数据的值在哪里产生、在哪里使用，程序漏洞分析中可以利用这些信息对程序合法性进行判断。
- **全局分析**
  - 也称为过程间分析。主要是从全局角度分析源代码结构。他在抽象语法树AST和控制流图CGF的基础上对程序的函数使用情况进行分析，根据这些函数之间的调用关系生成函数调用图，并在此基础上生成函数的函数摘要，以便在遍历函数执行路径遇到函数调用时，通过对函数摘要信息的分析代替对函数的分析。

### 第二讲

#### 给出一段C源程序和根据GCC生成的规范化文本，画出该中间表示对应的抽象语法树AST。

#### 结合中间表示和AST，画出对应的以基本块为单位的控制流图（基本块中可以用语句编号代替语句属性信息，其它信息省略）

### 第三讲

#### 基本块的定义以及确定基本块的原则。

- **基本块定义：**是一个最大化的指令序列，程序执行只能从这个序列的第一条指令进入，从这个序列的最后一条指令退出。
- **原则**：
  - 控制流只能从基本块中的第一个指令进入该块。也就是说，没有跳转到基本块中间的转移指令。
  -  除了基本块的最后一个指令，控制流在离开基本块之前不会有跳转。

#### 控制流图中循环的识别

- 必经结点概念；结点n的必经结点集D(n)迭代求取过程
- 回边概念；回边的确定
- 如何由回边确定循环的集合思想和算法

### 第四讲

#### 过程间分析的任务及步骤。

### 第五讲

#### 根据检测内存漏洞数据结构，说明如何提取指针属性信息，包括指针的声明、赋值、内存分配和释放操作过程。

#### 什么是空指针引用漏洞，根据检测内存漏洞数据结构说明空指针引用静态检测的方法。

### 第六讲

#### 内存泄露的定义和危害。

- **内存泄漏定义**：是指申请的内存空间在使用结束后未被合理释放，从而导致程序执行时发生异常。简单来说，就是指使用内存空间的指针在生命期结束后被销毁，而其指向的内存空间未被释放，或对内存空间的释放方式错误，从而造成的该块内存空间无法被正常使用。

- **内存泄漏危害**：内存空间的生存周期是从被成功申请至该空间被显式释放或者系统运行结束。内存泄露问题会导致系统运行缓慢、系统运行故障等问题。内存泄露问题本身并不复杂，但是由于软件系统的复杂结构致使检测该类问题具有一定的难度。

  

#### 说明内存泄露的几种类型，并根据检测内存漏洞数据结构描述针对这几类内存泄露进行检测的方法。

- **内存空间未释放**：分配的空间未被释放，这个是最常见的内存泄漏类型。需要在每个作用域结束时对该问题进行检测，确定本作用域申请的无用内存空间是否已全部释放。
- **释放静态分配的空间：**这种情况是指将静态变量的地址赋给了某指针，其后又将该指针指向的内存空间释放。如：int a=6;  int *p=&a; delete p; 可以把该类错误归结为内存泄漏错误。
  - 对该类问题的检测方法是查看释放指针引用的内存空间的分配类型，若该内存空间的类型为静态分配，则判定此处发生内存泄漏。即若指针对应的meminfo变量的type值为false，判定该处发生内存泄漏问题。
- **释放类型发生错误：**动态分配的空间可能是单独的变量或者是一个数组。二者对应的释放方法不同，如果混淆使用就会发生内存泄露问题。如：char *p1=new char; char *p2=new char[5]; 在第一句分配了一个字符元素，第二个语句分配了一个包含五个字符元素的数组，对第二个内存空间的释放方法为：delete []p2; 若错误的使用了delete p2对该空间进行释放，就会发生内存泄漏问题。
  -  该类型问题的检测方法是在遇到释放语句时，查看该指针对应的内存空间属性，若其对应的meminfo变量的size值不为1时，其释放方式必须是delete []形式，否则判定此处发生内存泄漏问题。
- **释放方式发生错误：**在C/C++语言中，常用的动态内存分配方式有三种：malloc和new。malloc申请的内存空间应用free释放，new申请的空间用delete释放。可以把使用错误的释放方式引起的问题归结为内存泄漏问题，如对new申请的空间调用了free进行释放。
  - 对此类问题的检测是通过检查释放指针引用的内存空间的malloctype属性。判定该块内存的申请方式和释放方式是否配对。若操作不匹配，则判定此处发生内存泄漏。

#### 什么是缓冲区溢出，缓冲区溢出攻击的根本原因？

- **缓冲区（Buffer）：**操作系统或程序员会按照需要开辟一个合适大小的连续内存空间用来临时存放数据，计算机科学将这段内存空间称为缓冲区。

- **缓冲区溢出定义：**是指当程序向某块分配的内存中读写数据时，读写的数据大小超出了已分配的内存的大小，从而致使访问的地址空间超出合法的范围，导致程序中合法的数据被覆盖或者非法读取。
- **缓冲区溢出攻击：**假设被覆盖的空间正好存储有重要的数据或指令，并且溢出数据也经过攻击者的巧妙设计，那么就可以获得程序控制流程，进而执行攻击指令，或者篡改系统的重要数据（如密码、权限、资金）等，实现缓冲区溢出攻击。
- **缓冲区溢出攻击的根本原因：**在于冯·诺伊曼结构计算机的数据与指令没有分开，因此用户可以利用数据来修改指令。

#### 根据检测内存漏洞数据结构说明缓冲区溢出的检测方法。

- 对分配的空间大小的确认
- 对空间访问位置的确认
- 有关控制流和变量取值的问题
- 字符串问题
- 一些系统函数库内的函数问题
- **缓冲区溢出检测方法：**
  - 根据指针名称在locscope链表中查找指针的信息，  包括指针引用空间的id和指针当前的索引值varinfo.curindex。然后根据id查找地址空间的属性，如该地址空间内的元素个数meminfo.size。
  - 若变量i在循环体内，则运用递归求解技术根据循环变量取值和循环执行次数求解出变量i的取值范围；否则通过区间运算技术求解出变量i的取值范围。
  - 判断对内存的访问是否合法，即对指针引用的每块地址空间和变量i的每个取值区间[xl,x2]判断是否满足 0<=varinfo.curindex+xl<meminfo.size 和 0<=varinfo.curindex+x2<meminfo.size。若同时满足这两个不等式，则不存在缓冲区溢出，否则判定此处空间访问存在缓冲区溢出问题。



