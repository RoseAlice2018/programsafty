## 考试重点

[toc]



### 第一讲：

#### 软件代码漏洞分类，并简要加以说明

1. 输入验证与表示
   1. 安全问题起因于对输入的信息过度信任，对输入信息未做任何验证引发的安全问题。如：缓冲区溢出、跨站脚本、SQL注入、cache攻击等。
2. API误用
   1. 调用者违反了调用者和被调者之间的约定。如：危险函数、堆检查、未检查的返回值等。
3. 安全特征
   1. 安全特征主要关系到认证、访问控制、机密性、密码、权限管理等方面的内容。如：不安全随机数、最小权限违规、缺少访问控制、口令管理、隐私违规等。
4. 时间与状态
   1. 在多核、多CPU或者分布式系统，经常会发生两个事件同时发生（精确的时间）。线程、进程、时间以及状态的非预期交互可能引起程序缺陷。如：死锁、固定会话、访问资源冲突、不安全临时文件等。
5. 错误处理
   1. 错误处理不足或不处理；产生错误时泄漏了太多信息或不能安全处理这些信息。
6. 代码质量
   1. 软件质量欠佳可能导致不可预知的行为。如：空指针调用、内存泄露、未初始化变量、未释放资源、释放后使用、双重释放等。
7. 封装
   1. 封装的作用是画出清晰的边界。信任与信任模型需要小心处理边界问题。如服务器上，经验证的数据和未经验证的数据之间（可信任边界违规），一个用户数据和另一个用户的数据之间（用户间数据泄露），允许用户看到的数据和不允许用户看到的数据之间（权限控制）、系统数据和调试信息的泄露等。

#### 什么是程序的静态检测和动态检测？两种检测方法各有什么特点？

1. 动态检测：就是通过运行软件，在程序运行过程中注入测试数据，观察程序运行是否正常、输出是否符合程序意图，达到寻找程序漏洞的目的。
   1. 动态检测是一种精确的检测方法。
   2. 动态检测分析结果往往依赖特定的输入、调度和执行路径，容易出现错误定位不准确、漏报等情况。
2. 静态检测：不实际运行程序情况下，通过扫描程序的代码，从程序代码的内部结构和特性上检测漏洞。
   1. 静态检测审核速度快。
   2. 会产生误报和漏报现象。

#### 简要说明哪几类问题可以应用软件静态分析技术及其起到的作用。

- 类型检查
  - 消除全部类型的编程错误，通过编译时捕获错误来防止运行错误。
- 风格检查
  - 纯粹的风格检查程序强制执行的规则一般与空格、命名、注释、程序结构等相关。风格检查所展示的错误往往都是影响代码的可读性和可维护性，不会指出程序运行时会发生的错误。
- 程序理解
  - 帮助用户搞懂代码库中的大量代码。如：提供程序的 概貌视图、查找本方法的所有应用等等。
- 程序验证和属性检查
  - 程序验证工具接受一份规格说明和一份代码，尝试证明该代码忠实实现了这份规格说明。目前程序验证还不能处理任何大型的程序。
    		目前，更为常见的程序验证是根据部分程序行为的部分规格说明对软件进行检查，称为属性检查。
- Bug查找
  - 指出程序以程序员设想之外的方式运行的一些地方。
- 安全审查
  - 以安全为中心的静态分析往往使用了许多技术，现代安全审查工具往往更像是一种属性检查和Bug查找程序的混合体。

#### 请画出软件安全静态检测的基本结构图；说明本地分析和全局分析都是针对什么情况的分析手段，都包含什么技术。

![](C:\Users\15052\Desktop\博客\程序安全检测\静态分析框架图.png)

- 预处理
  - 整个系统的入口，也是其他各部分工作的基础。其主要任务是读取待检测的文件，对其进行词法分析、语法分析等操作，并抽取文件中有价值的信息生成抽象语法树(AST)。
- 控制流分析
  - 该部分主要功能是生成待检测源代码的控制流图CFG（control flow graph）。他通过遍历预处理中生成的抽象语法树，依据程序的执行规则，分析程序的可能执行路径，生成CFG供后续检测工具使用。
- 数据流分析
  - 数据流分析指的是一组用来获取有关数据是如何沿着程序执行路径流动的技术，通常通过对某个函数控制流图的遍历，来记录数据的值在哪里产生、在哪里使用，程序漏洞分析中可以利用这些信息对程序合法性进行判断。
- **全局分析**
  - 也称为过程间分析。主要是从全局角度分析源代码结构。他在抽象语法树AST和控制流图CGF的基础上对程序的函数使用情况进行分析，根据这些函数之间的调用关系生成函数调用图，并在此基础上生成函数的函数摘要，以便在遍历函数执行路径遇到函数调用时，通过对函数摘要信息的分析代替对函数的分析。

### 第二讲

#### 给出一段C源程序和根据GCC生成的规范化文本，画出该中间表示对应的抽象语法树AST。

#### 结合中间表示和AST，画出对应的以基本块为单位的控制流图（基本块中可以用语句编号代替语句属性信息，其它信息省略）

- 程序中基本块的入口语句包括：
  1.程序的第一条语句
  2.转移语句的目标语句
  3.紧跟在条件转移语句后面的语句

- 例子

  ```
  源程序
  int fib(int m)
  { int f0=0,f1=1,f2,i;
     if(m<=1){return m;}
     else
      { for(i=2;i<=m;i++)
         { f2=f0+f1;
            f0=f1;
            f1=f2;
         }
         return f2;
      }
  }
  中间表示
        receive  m //程序的入口 符合条件一
        f0 ← 0
        f1 ← 1
        if m<=1 goto L3
        i ← 2;//条件转移语句后 符合条件三
  L1:if  i<=m goto L2 //转移语句的目标语句 符合条件二
        return f2 // 条件转移语句后的语句 符合条件三
  L2:f2 ← f0+f1 //转移语句的目标语句 符合条件二
        f0 ← f1
        f1 ← f2
        i ← i+1
        goto L1
  L3:return  m  //转移语句的目标语句 符合条件二
  
  ```

  ![](C:\Users\15052\Desktop\博客\程序安全检测\控制流图.png)

  ![](C:\Users\15052\Desktop\博客\程序安全检测\控制流.png)

### 第三讲

#### 基本块的定义以及确定基本块的原则。

- **基本块定义：**是一个最大化的指令序列，程序执行只能从这个序列的第一条指令进入，从这个序列的最后一条指令退出。
- **原则**：
  - 控制流只能从基本块中的第一个指令进入该块。也就是说，没有跳转到基本块中间的转移指令。
  -  除了基本块的最后一个指令，控制流在离开基本块之前不会有跳转。

#### 控制流图中循环的识别

- **循环**：如果下列条件成立，我们就说流图中的一个结点集合L是一个循环：
  - 在L中有一个被称为循环入口的结点，它是唯一的其前驱可能在L之外的结点；
  - L中的每个结点都有一个到达L的入口结点的非空路径，并且该路径全部在L中

- 必经结点概念

  - 控制流图中，若从函数入口entry到i的每条可执行路径都包含d，则称结点d是结点i的必经点。
    循环的入口结点是循环中每一结点的必经结点。

- 结点n的必经结点集D(n)迭代求取过程

  - **必经结点集**： 结点n的必经结点集D(n)：控制流图结点n的所有必经结点的集合。

  - P(n)代表结点n的所有前驱结点集合，则结点d是结点n必经结点中充要条件结点d也是n的前驱P(n)中的任意结点的必经结点。

  - 算法先假设除首结点以外的所有结点的D(n)为所有结点集合，然后利用充要条件反复迭代，直到收敛。

    ```
    结点n必经结点集D(n)的迭代算法：
               D(n0)={n0};   //CFG入口结点n0	
               foreach(n      N- {n0})  
                      D(n)=N;   
                change=true;   //迭代是否有更新
                while(change==true)
                {      change=false;
                        foreach( n      N- {n0} )
                        {     NEWD= {n}      {    D(p)，p    P(n)}；//n所有前驱p的D(p)并
                               if( D(n) != NEWD)
                               {  
                                        change=true;
                                         D(n)=NEWD;
                                 }
                         }
                  }
    
    ```

    

- **回边概念**：

  - 在控制流图中，设d是结点n的必经点，若在图中，存在着从结点n到d的有向边，则称此有向边n→d为控制流图中的一条回边。
  - **循环的识别**：设n→d为一回边，则在流程图中，那些不经过结点d而能到达结点n的所有结点，包括结点d和n本身，便构成了控制流图中的一个循环。此循环以结点d为其惟一入口。 

- 回边的确定

- 如何由回边确定循环的集合思想和算法

  - 首先，通过必经结点集D(n)，可以求出CFG中的回边：
         若存在由n到D(n)中结点的有向边，则该边为回边。

  - 若n -> d是回边，那么就可以求出由它组成的循环：该循环是由结点d、n以及有通路不经过d到达n的所有结点组成，并且d是该循环的唯一入口结点 。

  -  算法基本思想：回边n->d组成的循环，将以d为其唯一入口，n是它的一个出口，则n的除了d外的所有前驱结点应属于循环，而这些新加入循环的结点也有该特点，重复以上步骤，直到所求出的前驱是d为止。

    ```
    回边n->d组成的循环算法利用栈加入前驱结点，算法如下：
               steak=空；
               loop={n，d}；  //初始循环只包含n和d
               push(n);
                while(steak不空)
                {
                          m=pop();
                           foreach( p     P(m) )
                           {   
                                  if(p       loop)
                                  {    loop=loop       {p};
                                         push(p);
                                   }
                             }
                   }
    
    ```

    

### 第四讲

#### 过程间分析的任务及步骤。

- **什么是过程间分析**：过程间分析也称为全局分析，主要是对程序进行整体分析，生成该程序的函数调用图。并在此基础上，根据函数间的调用关系，生成每个函数的函数摘要信息，以便在检测问题时通过对函数摘要信息的分析替代对调用函数的分析，从而避免对同一函数在不同上下文多次调用需要多次分析的问题。

  - ```
    void fun2(char* str1)
    {
    	char dest[10];
    	strcpy(dest,str1);
    }
    void fun1( )
    {
    	char* str="Buffer Overflow";
    	fun2(str);
    }
    
    ```

  - 函数fun2在没有上下文的相关信息时，无法判断strcpy的使用是否导致缓冲区溢出，因此需要进行过程间分析，构造出函数间的调用图，用以标识函数间的依赖关系，才能获取被调用函数的函数信息，达到函数间分析，提高检测精度。

- 方法一：基于函数内联的过程间分析

  - 是最简单的过程间分析方法，就是在函数调用处将被调用函数展开，在分析被调用函数时可以获取到调用处的上下文环境信息，从而实现上下文敏感的过程间分析。
  - 1）分析效率低：内部的部分程序语句对上下文环境没有任何副作用，但还是会在函数内联时被重复分析；
    2）无法处理库函数调用；
    3）无法递归调用。

- 方法二： 基于函数摘要的过程间分析

  - 基于函数摘要的过程间分析会在过程内分析的基础上收集被调用函数的部分信息，通过函数摘要来抽象一个函数调用的上下文信息和约束条件。以后再遇到关于该函数的函数调用时，就不需要再对该函数进行内联展开，而是直接使用摘要信息进行过程间的分析。
  - 现有的程序使用了大量的基础库，这些库函数比较通用且函数行为很固定，我们可以预先对这些库代码进行分析，收集其函数摘要信息或者手工定义其函数摘要，从而加速整个分析过程。

- **过程间分析步骤**：

  - 首先，为整个程序代码构建函数调用图（Call Graph,CG）；
    - 函数调用图：是对程序进行分析而生成的一个有向图。它是对函数间关系的静态描述，提供了一种函数之间调用关系的形式化表示方法。可以表示为G=(V，E)。其中，V代表某函数的调用图结点集合；E为有向边集合，代表函数间的调用关系。vlv2表示vl到v2存在-条有向边，v1结点中的函数调用了v2结点的函数。	
  - 然后，根据预设的全局分析调度策略，对CG中每个节点（对应一个函数）进行过程内分析，形成函数摘要；
  - 最终，给出CG每种可行的调用序列的分析结果。

- 函数摘要

  - summary=<Type, Retvalue,Constraint,SideEffect>
    - Type：表示函数的类型，包括函数参数类型，返回值类型，以及是否存在变参，是否有默认参数。
    - Retvalue：函数的返回值，代表着函数的执行结果，往往涉及到赋值等操作，实现数据流在函数间的传递。可以采用可能取值区间来近似估计运行时实际返回值。
    - Constraint：表示正确执行该函数必须满足的上下文环境的约束。
    - SideEffect：表示函数对被调用处上下文环境所产生的副作用。主要包括对外部变量的修改和函数内部与参数相关的、无法确定安全性的操作，细分为两类，一类是与内存有关的操作，如对外部动态分配空间的分配、释放、对全局指针的赋值、无法确定安全性的内存访问等。一类是与简单类型变量有关的操作。如外部简单变量的赋值等等。

### 第五讲

#### 根据检测内存漏洞数据结构，说明如何提取指针属性信息，包括指针的声明、赋值、内存分配和释放操作过程。

- **指针信息的提取：**
  - 与简单变量不同，指针数据必须预先对指针变量的指向目标进行分析。所以需要为每个程序点建立指针与指向内存对象的映射关系（p,{o})。
  - 静态分析的不确定性可能导致每个程序点的指针指向的为一个内存对象集合，即指针p和内存对象o是一对多的关系。
  - 需要考虑指针别名问题，即多个指针同时指向一块内存对象，即p和o是多对一的关系。
- 在检测源代码中存在的安全缺陷时，需要遍历代码的每一步操作，根据不同的操作类型提取、更新有关指针的信息：
  - 声明操作：
    - 指针的声明：为该指针变量分配一个varinfo类型的变量，并使用默认值填充该变量的信息，如指向内存空间标号的id设为0、当前索引位置设为0等。并将该变量添加到其对应作用域的变量链表中。
    - 数组的声明：首先生成一个meminfo的变量，存储其声明的变量空间信息。如为该空间自动生成的唯一标识id、该内存空间的类型、空间中存储的元素个数等信息，并将该空间的访问次数设置为1，type设置为false表示为静态申请空间。将该变量添加到对应作用域的内存空间链表中。然后为数组名定义一个varinfo变量，并设置其对应信息，如把引用id设置为刚才定义的一个meminfo变量的id。
  - 赋值操作：
    - 当指针被赋值时，首先检查赋值指针是否为空指针，若不为空，则将赋值指针的属性赋给被赋值指针属性，主要包括：
      		a)将被赋值指针的引用空间的引用次数减一；
      		b)将被赋值指针的引用id修改为赋值指针的id；
      		c)该赋值指针的引用id对应的空间地址的引用次数加一；
      		d)将被赋值指针的索引值设为赋值指针的索引值。
  - 内存分配：
    - 在遍历语法树中的语句节点遇到动态内存分配操作时,为该块内存空间定义一个meminfo类型的变量。主要包括：为该变量生成一个唯一标识id、该空间中存在的变量类型、存储的元素个数等等。最后把该meminfo类型的变量插入到当前的作用域的内存空间链表中。动态分配内存空间往往会与赋值操作关联在一起，对于其后变量的赋值操作参见上面的赋值操作部分。
  - 内存释放：
    - 在遇到内存释放操作时,从当前作用域开始,向上层逐层遍历varlist链表，根据节点中pname字段找到释放指针变量对应的varinfo数据结构。读取该结构的id字段并置为0。再在memlist中寻找id为刚才读取的id的meminfo，将该变量的visnum置为-1，表示该块空间已经被释放。

#### 什么是空指针引用漏洞，根据检测内存漏洞数据结构说明空指针引用静态检测的方法。

- 是指未被赋值或者指向非法地址空间的指针变量。
  - 指针是否为空，即指针对应的varinfo的id是否为0； 
    指针引用的地址空间是否被释放，即引用的空间id标识的内存空间的meminfo的visnum字段是否为-1；

### 第六讲

#### 内存泄露的定义和危害。

- **内存泄漏定义**：是指申请的内存空间在使用结束后未被合理释放，从而导致程序执行时发生异常。简单来说，就是指使用内存空间的指针在生命期结束后被销毁，而其指向的内存空间未被释放，或对内存空间的释放方式错误，从而造成的该块内存空间无法被正常使用。

- **内存泄漏危害**：内存空间的生存周期是从被成功申请至该空间被显式释放或者系统运行结束。内存泄露问题会导致系统运行缓慢、系统运行故障等问题。内存泄露问题本身并不复杂，但是由于软件系统的复杂结构致使检测该类问题具有一定的难度。

  

#### 说明内存泄露的几种类型，并根据检测内存漏洞数据结构描述针对这几类内存泄露进行检测的方法。

- **内存空间未释放**：分配的空间未被释放，这个是最常见的内存泄漏类型。需要在每个作用域结束时对该问题进行检测，确定本作用域申请的无用内存空间是否已全部释放。
- **释放静态分配的空间：**这种情况是指将静态变量的地址赋给了某指针，其后又将该指针指向的内存空间释放。如：int a=6;  int *p=&a; delete p; 可以把该类错误归结为内存泄漏错误。
  - 对该类问题的检测方法是查看释放指针引用的内存空间的分配类型，若该内存空间的类型为静态分配，则判定此处发生内存泄漏。即若指针对应的meminfo变量的type值为false，判定该处发生内存泄漏问题。
- **释放类型发生错误：**动态分配的空间可能是单独的变量或者是一个数组。二者对应的释放方法不同，如果混淆使用就会发生内存泄露问题。如：char *p1=new char; char *p2=new char[5]; 在第一句分配了一个字符元素，第二个语句分配了一个包含五个字符元素的数组，对第二个内存空间的释放方法为：delete []p2; 若错误的使用了delete p2对该空间进行释放，就会发生内存泄漏问题。
  -  该类型问题的检测方法是在遇到释放语句时，查看该指针对应的内存空间属性，若其对应的meminfo变量的size值不为1时，其释放方式必须是delete []形式，否则判定此处发生内存泄漏问题。
- **释放方式发生错误：**在C/C++语言中，常用的动态内存分配方式有三种：malloc和new。malloc申请的内存空间应用free释放，new申请的空间用delete释放。可以把使用错误的释放方式引起的问题归结为内存泄漏问题，如对new申请的空间调用了free进行释放。
  - 对此类问题的检测是通过检查释放指针引用的内存空间的malloctype属性。判定该块内存的申请方式和释放方式是否配对。若操作不匹配，则判定此处发生内存泄漏。

#### 什么是缓冲区溢出，缓冲区溢出攻击的根本原因？

- **缓冲区（Buffer）：**操作系统或程序员会按照需要开辟一个合适大小的连续内存空间用来临时存放数据，计算机科学将这段内存空间称为缓冲区。

- **缓冲区溢出定义：**是指当程序向某块分配的内存中读写数据时，读写的数据大小超出了已分配的内存的大小，从而致使访问的地址空间超出合法的范围，导致程序中合法的数据被覆盖或者非法读取。
- **缓冲区溢出攻击：**假设被覆盖的空间正好存储有重要的数据或指令，并且溢出数据也经过攻击者的巧妙设计，那么就可以获得程序控制流程，进而执行攻击指令，或者篡改系统的重要数据（如密码、权限、资金）等，实现缓冲区溢出攻击。
- **缓冲区溢出攻击的根本原因：**在于冯·诺伊曼结构计算机的数据与指令没有分开，因此用户可以利用数据来修改指令。

#### 根据检测内存漏洞数据结构说明缓冲区溢出的检测方法。

- 对分配的空间大小的确认
- 对空间访问位置的确认
- 有关控制流和变量取值的问题
- 字符串问题
- 一些系统函数库内的函数问题
- **缓冲区溢出检测方法：**
  - 根据指针名称在locscope链表中查找指针的信息，  包括指针引用空间的id和指针当前的索引值varinfo.curindex。然后根据id查找地址空间的属性，如该地址空间内的元素个数meminfo.size。
  - 若变量i在循环体内，则运用递归求解技术根据循环变量取值和循环执行次数求解出变量i的取值范围；否则通过区间运算技术求解出变量i的取值范围。
  - 判断对内存的访问是否合法，即对指针引用的每块地址空间和变量i的每个取值区间[xl,x2]判断是否满足 0<=varinfo.curindex+xl<meminfo.size 和 0<=varinfo.curindex+x2<meminfo.size。若同时满足这两个不等式，则不存在缓冲区溢出，否则判定此处空间访问存在缓冲区溢出问题。



