## 程序安全检测技术

### 第二讲 编译程序介绍和抽象语法树构造

- 文本抽象语法树结构

  - 结点编号   结点名称   描述字段

  - ```
    @6     function_decl name:@11  type: @12
    ```

  - 结点编号@6：称作结点标号，用符号@数字表示，它是抽象语法树上区分该节点的唯一标识，也是访问该节点的索引。

  - 结点名称function_decl : 结点的含义（函数）

  - 结点的属性描述字段列表： 每个属性形如name：@11，记录了该节点的各个属性字段名称及描述其具体特征所在的结点编号。

- GCC抽象语法树主要结点名称种类

  - 常量结点： 后缀是_cst;
  - 类型结点:    后缀往往是_type;
  - 声明结点:    后缀往往是_decl ;
  - 函数结点：function_decl ;
  - 语句结点: 后缀往往是_stmt;
  - 表达式结点: 后缀往往是_expr.

- 手工编写解析程序的基本流程

  - 源程序
  - 用GCC对源文件进行前端分析
  - 生成抽象语法树文本
  - 规范化的AST文本
  - 消除AST冗余信息
  - 建立抽象语法树
  - 输出抽象语法树
  - 结束

-  **规范化的AST文本**

  - 使得每个结点文本保持在同一行存储，并且规范显示格式，方便后期处理

  - 每个字段格式： 字段名 ： 字段值

    - 字段名以“ ： ” 结束 ， 字段名由多个含空格的字符串组成 ， “ ： ” 与字段名间可能有空格，“：”与字段值间一定有空格。
    - 字段值：为子节点编号（name: @11)   或直接为一个字符串或数值（Ingt：4）
    - 为方便AST提取信息和显示，可以去除每个字段格式间的空格

  - 示例：

  - ```
    原结点：
    @3      integer_type     name: @1       size: @5        prec: 32       sign: signed                  min : @6        max : @7
    规范结点：
    @3 integer_type name:@1 size:@5 prec:32 sign:signed min:@6 max:@7
    
    ```

- **消除冗余信息**

  - 原因：GCC产生的文本抽象语法树中包含许多编译信息，如由#include命令产生的内部函数、类型声明、出错信息、常量等。这些信息不利于代码分析。

  - 算法要达到的目标：消除文本中所有与分析数据流、控制流无关的结点并保持信息的完整性。最后重新排序结点编号。

    - 将结点分为三种类型
      - 有用结点 useful_Node:与分析数据流，控制流相关
      - 无用结点 useless_Node: 分析数据流，控制流无关结点
      - 待定结点 unknow_Node: 当前类型未被确定的结点

  - **消除冗余结点算法思想：**

    -  分析文本抽象语法树可以看出：和树根距离最近的结点一般是函数结点和声明结点，而且它们都有一个字段：
                     srcp: 文件名
          所以根据srcp字段先找出抽象语法树中的根结点，并将这些结点设为有用结点，然后对这些结点进行迭代标记，标记这些结点的字段子结点为有用结点，直到没有新的有用结点加入为止‘

    - 例如

    - ```
      @2786   function_decl    name: @2791    type: @2792    srcp: ast1.c:2  link: extern   body: @2793 
      先标记@2786为有用结点，再依次标记@2791, @2792 , @2793 为有用结点，然后再继续标记新增三个结点的各个字段子结点。
      
      ```

    - 步骤一：对抽象语法树进行一次扫描，就完成了对函数结点、声明结点的标定。

      - 如果结点 srcp 字段的值为输入文件名，则此结点为有用结点。
      - 如果结点 srcp 字段的值为其他值，则此结点为无用结点。
      - 如果结点不含有 scrp 字段，则此结点暂时为待定结点。

    - 步骤二：下面对函数结点和声明结点为根的子树进行标定。

      - 有用结点的子结点如果它还是待定结点，那就标定为有用结点，同样的处理无用结点。
      - 如果一个结点的父结点中既有有用结点，也有无用结点，那么就称它为冲突结点。为了保持信息的完整性，将这样的结点标定为有用结点。

    - 步骤三：由于将所有的库函数、内部函数及其相关信息都删除了，还要找回源文件用到的库函数信息，主要是遍历 call_expr(调用表达式)的子树结点。

    - **算法描述**

    - ```
      输入：文本抽象语法树(.tu文件)
      	输出：规范化文本抽象语法树
      	算法过程：
      	声明：int number;//存放编号
      	(1)对 .tu文件进行格式化，使同一结点在同一行上；
      	(2)将所有的结点类型都初始化为待定结点；
      	(3) for i:=1 to n (总行数) do
      	(4) 	if 第 i 行含有子串"scrp" then
      	(5)	     if scrp:字段的值=文件名 then 结点标为有用结点
      	(6) 	     else 标定为无用结点;
      	(7) for j:=1 to n do
      	(8) 	if 不是待定结点 then
      	(9)	 begin
      	(10) 	 number:=找到它子结点的编号;
      	(11) 	 while 本行不结束 do
      	(12)	 begin
      	(13)	     if 是有用结点的子结点且是待定结点 then 标定为有用结点；
      	(14) 	    else if 是无用结点的子结点且是待定结点，then 标为无用结点;
      	(15) 	    number:=找到下一子结点的编号;
      	(16)	 end;
      	(17)         end;
      	(18)      遍历 call_expr结点的子树结点找回源程序中用到的库函数的信息;
      	(20) 将所有有用结点的信息返回。
      
      
      ```

- **建立抽象语法树**

  - 1）重新排序结点编号

    -  编号映射：由于规范化的文本抽象语法树的结点编号是不连续的，会给遍历和其他处理带来不便，所以将规范化的抽象语法树的编号集合映射到一个连续的空间中。

    - 定义：编号映射--设集合 A，B 是自然数集合 N 的子集,函数:
      		 F:AB，且对于任意aA，F(a)=b， b∈B，则称 F 为一个编号映射。

    - 编号映射主要是通过构建编号映射表来实现，将所有的编号映射到 1~N(结点总个数)。这样一来既节省了大量的空间又使得更易于建立抽象语法。

    - 设计编号映射表

    - ```
      typedef  struct  numbermap{
      			CString  oldNum;  //原结点编号, @num
      			int  newNum;         //映射新标号
      		}numberMap;
      	(1)   numberMap *nMap=malloc(结点数n*sizeof(numberMap)); 
      	(2)	int mapNum=0;
      	(3) 	for i=1 to n do
      	(4) 	begin
      	(5) 	       nMap[i].oldNum:=第i行首结点编号@num;
          (6) 	       nMap[i].newNum=mapNum;	
          (7)          mapNum++;
          (8)    end;
      
      ```

    - 节点编号映射算法

    - ```
      结点编号映射算法
      	输入：去除冗余结点的文本抽象语法树；
      	输出：规范抽象语法树文本
      	算法的基本过程：
      	(1)   for i:=1 to n do
      	(2)	     begin
      	(3) 		读入第i个结点的所有信息：
      	(4) 		foreach 字段 in 该结点所有字段 do
      	(5) 	  	     if 该字段值为子结点@num  then
      	(6) 	    		for j=1 to n do
      	(7)         		     if  nMap[j].oldNum=子结点@num then
      	(8)        		         替换子结点@num为@nMap[j].newNum
      	(9)        end;  
          (10)  for i:=1 to n do
          (11)        替换首结点编号@num为nMap[j].newNum   	
      ```

  - 2）消除冗余字段

    - 定义：字段冗余消除规则集--根据结点的类型与分析数据流、控制流的关系，制定的用来决定字段是否被消除的规则的集合。规则如下：
      - (1)类型结点(types) 中用来描述简单类型的类型结	点的所有字段应该被全部删除。
      - (2)标识符结点中，用来描述标识符长度的字段lngt 	应该被删除。
      - (3)scope_stmt 结点中，只保留标识复合语句开始	的 begin 字段、标识结束的end 字段、line 字段和	标识下一个语句的 next 字段。
      - (4)消除所有结点中的 srcp 字段、algn 字段。
      - (5)消除所有指向结点已被消除的字段。

  - 3)抽象语法树的存储结构设计

    - 可以采用邻接表的形式存储建立的抽象语法树：









